(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{450:function(e,t,n){"use strict";n.r(t);var a=n(2),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"function-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#function-component"}},[e._v("#")]),e._v(" Function Component")]),e._v(" "),t("h2",{attrs:{id:"钩子函数的使用注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#钩子函数的使用注意事项"}},[e._v("#")]),e._v(" 钩子函数的使用注意事项：")]),e._v(" "),t("ol",[t("li",[e._v("钩子只能在React组件和自定义钩子中使用")]),e._v(" "),t("li",[e._v("钩子不能在嵌套函数或其他语句（if、switch、white、for等）中使用")])]),e._v(" "),t("h3",{attrs:{id:"_1-useeffect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-useeffect"}},[e._v("#")]),e._v(" 1.useEffect")]),e._v(" "),t("p",[e._v("useEffect语法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("useEffect(didUpdate);\n")])])]),t("p",[t("code",[e._v("useEffect()")]),e._v("需要一个函数作为参数，你可以这样写：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("useEffect(()=>{\n    /* 编写那些会产生副作用的代码 */\n});\n")])])]),t("p",[t("code",[e._v("useEffect()")]),e._v("中的回调函数会在组件每次渲染完毕之后执行，这也是它和写在函数体中代码的最大的不同，函数体中的代码会在组件渲染前执行，而"),t("code",[e._v("useEffect()")]),e._v("中的代码是在组件渲染后才执行，这就避免了代码的执行影响到组件渲染。")]),e._v(" "),t("p",[t("img",{attrs:{src:"F:%5Cweb-react%5CuseEffect%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5.png",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"_2-usememo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-usememo"}},[e._v("#")]),e._v(" 2.useMemo")]),e._v(" "),t("p",[e._v("useMemo和useCallback十分相似，"),t("strong",[e._v("useCallback用来缓存函数对象")]),e._v("，"),t("strong",[e._v("useMemo用来缓存函数的执行结果")]),e._v("。在组件中，会有一些函数具有十分的复杂的逻辑，执行速度比较慢。闭了避免这些执行速度慢的函数返回执行，可以通过useMemo来缓存它们的执行结果，像是这样：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const result = useMemo(()=>{\n    return 复杂逻辑函数();\n},[依赖项])\n")])])]),t("p",[t("strong",[e._v("useMemo中的函数会在依赖项发生变化时执行")]),e._v("，注意！是执行，这点和useCallback不同，useCallback是创建。执行后返回执行结果，如果依赖项不发生变化，则一直会返回上次的结果，不会再执行函数。这样一来就避免复杂逻辑的重复执行。")]),e._v(" "),t("h3",{attrs:{id:"_3-usecallback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-usecallback"}},[e._v("#")]),e._v(" 3.useCallback")]),e._v(" "),t("h5",{attrs:{id:"usecallback的作用其实是用来避免子组件不必要的rerender"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usecallback的作用其实是用来避免子组件不必要的rerender"}},[e._v("#")]),e._v(" "),t("code",[e._v("useCallback")]),e._v("的作用其实是用来避免子组件不必要的reRender")]),e._v(" "),t("p",[e._v("useCallBack在什么情况下使用？")]),e._v(" "),t("p",[t("strong",[e._v("在往子组件传入了一个函数并且子组件被React.momo缓存了的时候使用")])]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("useCallBack的作用不是阻止函数创建，而是在依赖不变的情况下返回旧函数地址（保持地址不变）。")]),e._v(" "),t("p",[e._v("React.memo()是通过校验props中的数据是否改变的来决定组件是否需要重新渲染的一种缓存技术，"),t("strong",[e._v("具体点说React.memo()其实是通过校验Props中的数据的内存地址是否改变来决定组件是否重新渲染组件的一种技术。")])]),e._v(" "),t("h4",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("useCallBack不要每个函数都包一下，否则就会变成反向优化，useCallBack本身就是需要一定性能的")])]),e._v(" "),t("li",[t("strong",[e._v("useCallBack并不能阻止函数重新创建,它只能通过依赖决定返回新的函数还是旧的函数,从而在依赖不变的情况下保证函数地址不变")])]),e._v(" "),t("li",[t("strong",[e._v("useCallBack需要配合React.memo使用")])])]),e._v(" "),t("h3",{attrs:{id:"_4-useref"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-useref"}},[e._v("#")]),e._v(" 4.useRef")]),e._v(" "),t("p",[e._v("useRef()返回的是一个普通的JS对象，JS对象中有一个current属性，它指向的便是原生的DOM对象。上例中，如果想访问div的原生DOM对象，只需通过"),t("code",[e._v("divRef.current")]),e._v("即可访问，它可以调用DOM对象的各种方法和属性，但还是要再次强调：慎用！")]),e._v(" "),t("p",[t("strong",[e._v("尽量减少在React中操作原生的DOM对象")]),e._v("，如果实在非得操作也尽量是那些不会对数据产生影响的操作，像是设置焦点、读取信息等。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import React, {useRef} from 'react';\n\nconst MyComponent = () => {\n\n    const divRef = useRef();\n\n    const clickHandler = () => {\n        console.log(divRef);\n    };\n\n    return (\n            <div ref={divRef} onClick={clickHandler}>一个div</div>\n           \n    );\n};\n\nexport default MyComponent;\n")])])]),t("h3",{attrs:{id:"_5-usereducer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-usereducer"}},[e._v("#")]),e._v(" 5.useReducer")]),e._v(" "),t("p",[t("code",[e._v("Reducer")]),e._v("可以翻译为“整合器”，它的作用就是"),t("strong",[e._v("将那些和同一个"),t("code",[e._v("state")]),e._v("相关的所有函数都整合到一起，方便在组件中进行调用")]),e._v("。")]),e._v(" "),t("p",[t("strong",[e._v("使用场景")]),e._v("：只适用于那些比较复杂的"),t("code",[e._v("state")]),e._v("，对于简单的"),t("code",[e._v("state")]),e._v("使用"),t("code",[e._v("Reducer")]),e._v("只能是徒增烦恼。")]),e._v(" "),t("p",[e._v("**语法如下：**和"),t("code",[e._v("State")]),e._v("相同"),t("code",[e._v("Reducer")]),e._v("也是一个钩子函数，")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const [state, dispatch] = useReducer(reducer, initialArg, init);\n")])])]),t("p",[e._v("它的返回值和"),t("code",[e._v("useState()")]),e._v("类似，第一个参数是"),t("code",[e._v("state")]),e._v("用来读取"),t("code",[e._v("state")]),e._v("的值，第二个参数同样是一个函数，不同于"),t("code",[e._v("setState()")]),e._v("这个函数我们可以称它是一个“派发器”，通过它可以向"),t("code",[e._v("reducer()")]),e._v("发送不同的指令，控制"),t("code",[e._v("reducer()")]),e._v("做不同的操作。")]),e._v(" "),t("p",[e._v("它的参数有三个，第三个我们暂且忽略，只看前两个。"),t("code",[e._v("reducer()")]),e._v("是一个函数，也是我们所谓的“整合器”。它的返回值会成为新的"),t("code",[e._v("state")]),e._v("值。当我们调用"),t("code",[e._v("dispatch()")]),e._v("时，"),t("code",[e._v("dispatch()")]),e._v("会将消息发送给"),t("code",[e._v("reducer()")]),e._v("，"),t("code",[e._v("reducer()")]),e._v("可以根据不同的消息对"),t("code",[e._v("state")]),e._v("进行不同的处理。"),t("code",[e._v("initialArg")]),e._v("就是"),t("code",[e._v("state")]),e._v("的初始值，和"),t("code",[e._v("useState()")]),e._v("参数一样。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import {useReducer, useState} from 'react';\n\nconst reducer = (state, action) => {\n    switch(action.type){\n        case 'add':\n            return state + 1;\n        case 'sub':\n            return state - 1;\n    }\n};\n\nfunction App() {\n\n    const [count, countDispath] = useReducer(reducer,1);\n\n    return (\n        <div className=\"App\">\n            {count}\n\n            <div>\n                <button onClick={()=>countDispath({type:'sub'})}>-</button>\n                <button onClick={()=>countDispath({type:'add'})}>+</button>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n")])])]),t("h3",{attrs:{id:"_6-usecontext"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-usecontext"}},[e._v("#")]),e._v(" 6.useContext")]),e._v(" "),t("h5",{attrs:{id:"usecontext作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usecontext作用"}},[e._v("#")]),e._v(" "),t("strong",[e._v("useContext作用")])]),e._v(" "),t("h5",{attrs:{id:"a-usecontext可以帮助我们跨越组件层级直接传递变量-实现数据共享。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#a-usecontext可以帮助我们跨越组件层级直接传递变量-实现数据共享。"}},[e._v("#")]),e._v(" a.useContext可以帮助我们跨越组件层级直接传递变量，实现数据共享。")]),e._v(" "),t("h5",{attrs:{id:"b-context的作用就是对它所包含的组件树提供全局共享数据的一种技术。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-context的作用就是对它所包含的组件树提供全局共享数据的一种技术。"}},[e._v("#")]),e._v(" b.Context的作用就是对它所包含的组件树提供全局共享数据的一种技术。")]),e._v(" "),t("p",[e._v("代码示例：点击+1的时候，父组件和子组件都能获取到当前点击的次数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import React,{useContext, useState, createContext} from 'react';\nimport {Button} from 'antd';\nimport '../../App.css';\n \nconst CountContext = createContext();\n \nconst TestContext = () =>{\n    const [count, setCount] = useState(0);\n    console.log(CountContext);\n    console.log(useContext(CountContext));\n    return(\n      <div>\n          <p>父组件点击次数：{count}</p>\n          <Button type={\"primary\"} onClick={()=>setCount(count+1)}>点击+1</Button>\n          <CountContext.Provider value={count}>\n            <Counter/>\n          </CountContext.Provider>\n      </div>\n  )\n};\n \nconst Counter = () => {\n    const count = useContext(CountContext);\n    console.log(CountContext);\n    // console.log(count);\n    // console.log(useContext(CountContext));\n    return (\n        <div>\n            <p>子组件获得的点击数量：{count}</p>\n        </div>\n    );\n};\n \nexport default TestContext;\n")])])]),t("p",[e._v("Provider译为生产者，和Consumer消费者对应。Provider会设置在外层组件中，通过value属性来指定Context的值。这个Context值在所有的Provider子组件中都可以访问。Context的搜索流程和JS中函数作用域类似，当我们获取Context时，React会在它的外层查找最近的Provider，然后返回它的Context值。如果没有找到Provider，则会返回Context模块中设置的默认值。")]),e._v(" "),t("h3",{attrs:{id:"_7-useimperativehandle"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-useimperativehandle"}},[e._v("#")]),e._v(" 7.useImperativeHandle")]),e._v(" "),t("p",[e._v("在React中可以通过forwardRef来指定要暴露给外部组件的ref：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const MyButton = forwardRef((props, ref) => {\n    return <button ref={ref}>自定义按钮</button>\n});\n")])])]),t("p",[e._v("上例中，MyButton组件将button的ref作为组件的ref向外部暴露，其他组件在使用MyButton时，就可以通过ref属性访问：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<MyButton ref={btnRef}/>\n")])])]),t("p",[t("strong",[e._v("通过useImperativeHandle可以手动的指定ref要暴露的对象")]),e._v("，比如可以修改MyButton组件如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const MyButton = forwardRef((props, ref) => {\n\n    useImperativeHandle(ref,()=> {\n        return {\n            name:'孙悟空'\n        };\n    });\n\n    return <button>自定义按钮</button>\n});\n")])])]),t("p",[e._v("useImperativeHandle的第二个参数是一个函数，函数的返回值会自动赋值给ref（current属性）。上例中，我们将返回值为"),t("code",[e._v("{name:'孙悟空'}")]),e._v("，当然返回孙悟空没有什么意义。实际开发中，我们可以将一些操作方法定义到对象中，这样可以有效的减少组件对DOM对象的直接操作。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const MyButton = forwardRef((props, ref) => {\n\n    const btnRef = useRef();\n\n    useImperativeHandle(ref,()=> {\n        return {\n            setDisabled(){\n                btnRef.current.disabled = true;\n            }\n        };\n    });\n\n    return <button ref={btnRef}>自定义按钮</button>\n});\n\nconst App = () => {\n    \n    const btnRef = useRef();\n\n    const clickHandler = () => {\n        btnRef.current.setDisabled();\n    };\n\n    return <div>\n        <MyButton ref={btnRef}/>\n        <button onClick={clickHandler}>点击</button>\n    </div>;\n};\n")])])]),t("h3",{attrs:{id:"_8-uselayouteffect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-uselayouteffect"}},[e._v("#")]),e._v(" 8.useLayoutEffect")]),e._v(" "),t("p",[e._v("useLayoutEffect的方法签名和useEffect一样，功能也类似。")]),e._v(" "),t("p",[e._v("不同点在于，"),t("strong",[e._v("useLayoutEffect的执行时机要早于useEffect")]),e._v("，它会"),t("strong",[e._v("在DOM改变后调用")]),e._v("。在老版本的React中它和useEffect的区别比较好演示，React18中，useEffect的运行方式有所变化，所以二者区别不好演示。")]),e._v(" "),t("p",[e._v("useLayoutEffect"),t("strong",[e._v("使用场景")]),e._v("不多，实际开发中，在effect中需要修改元素样式，且使用useEffect会出现闪烁现象时可以使用useLayoutEffect进行替换。")]),e._v(" "),t("p",[t("img",{attrs:{src:"F:%5Cweb-react%5C%E4%B8%89%E4%B8%AAeffect%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%E4%B8%8D%E5%90%8C.png",alt:""}})])])}),[],!1,null,null,null);t.default=s.exports}}]);