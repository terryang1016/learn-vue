(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{458:function(e,t,a){"use strict";a.r(t);var r=a(2),v=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vite学习笔记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vite学习笔记"}},[e._v("#")]),e._v(" vite学习笔记")]),e._v(" "),t("h2",{attrs:{id:"一-vite的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-vite的优势"}},[e._v("#")]),e._v(" 一.vite的优势")]),e._v(" "),t("h5",{attrs:{id:"_1-vite-通过在一开始将应用中的模块区分为-依赖-和-源码-两类-改进了开发服务器启动时间。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-vite-通过在一开始将应用中的模块区分为-依赖-和-源码-两类-改进了开发服务器启动时间。"}},[e._v("#")]),e._v(" 1.Vite 通过在一开始将应用中的模块区分为 "),t("strong",[e._v("依赖")]),e._v(" 和 "),t("strong",[e._v("源码")]),e._v(" 两类，改进了开发服务器启动时间。")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("依赖")]),e._v(" 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。")]),e._v(" "),t("p",[e._v("Vite 将会使用 "),t("a",{attrs:{href:"https://esbuild.github.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("esbuild"),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://cn.vitejs.dev/guide/dep-pre-bundling.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("预构建依赖"),t("OutboundLink")],1),e._v("。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("源码")]),e._v(" 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。")]),e._v(" "),t("p",[e._v("Vite 以 "),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer"}},[e._v("原生 ESM"),t("OutboundLink")],1),e._v(" 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。")]),e._v(" "),t("h5",{attrs:{id:"_2-缓慢的更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓慢的更新"}},[e._v("#")]),e._v(" 2.缓慢的更新")]),e._v(" "),t("h5",{attrs:{id:"在-vite-中-hmr-是在原生-esm-上执行的。当编辑一个文件时-vite-只需要精确地使已编辑的模块与其最近的-hmr-边界之间的链失活-1-大多数时候只是模块本身-使得无论应用大小如何-hmr-始终能保持快速更新。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在-vite-中-hmr-是在原生-esm-上执行的。当编辑一个文件时-vite-只需要精确地使已编辑的模块与其最近的-hmr-边界之间的链失活-1-大多数时候只是模块本身-使得无论应用大小如何-hmr-始终能保持快速更新。"}},[e._v("#")]),e._v(" "),t("strong",[e._v("在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活["),t("a",{attrs:{href:"https://cn.vitejs.dev/guide/why.html#footnote-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("1]"),t("OutboundLink")],1),e._v("（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。")])]),e._v(" "),t("p",[e._v("Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 "),t("code",[e._v("304 Not Modified")]),e._v(" 进行协商缓存，而依赖模块请求则会通过 "),t("code",[e._v("Cache-Control: max-age=31536000,immutable")]),e._v(" 进行强缓存，因此一旦被缓存它们将不需要再次请求。")])])]),e._v(" "),t("h2",{attrs:{id:"二-搭建第一个-vite-项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-搭建第一个-vite-项目"}},[e._v("#")]),e._v(" 二.搭建第一个 Vite 项目")]),e._v(" "),t("h5",{attrs:{id:"_1-通过附加的命令行选项直接指定项目名称和你想要使用的模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-通过附加的命令行选项直接指定项目名称和你想要使用的模板"}},[e._v("#")]),e._v(" 1.通过附加的命令行选项直接指定项目名称和你想要使用的模板")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# npm 6.x\nnpm create vite@latest my-vue-app --template vue\n\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n")])])]),t("h2",{attrs:{id:"三-配置vite"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-配置vite"}},[e._v("#")]),e._v(" 三.配置vite")]),e._v(" "),t("h5",{attrs:{id:"_1-在配置中使用环境变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-在配置中使用环境变量"}},[e._v("#")]),e._v(" 1.在配置中使用环境变量")]),e._v(" "),t("p",[e._v("环境变量通常可以从 "),t("code",[e._v("process.env")]),e._v(" 获得。")]),e._v(" "),t("p",[e._v("注意 Vite 默认是不加载 "),t("code",[e._v(".env")]),e._v(" 文件的，因为这些文件需要在执行完 Vite 配置后才能确定加载哪一个，举个例子，"),t("code",[e._v("root")]),e._v(" 和 "),t("code",[e._v("envDir")]),e._v(" 选项会影响加载行为。不过当你的确需要时，你可以使用 Vite 导出的 "),t("code",[e._v("loadEnv")]),e._v(" 函数来加载指定的 "),t("code",[e._v(".env")]),e._v(" 文件。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import { defineConfig, loadEnv } from 'vite'\n\nexport default defineConfig(({ command, mode }) => {\n  // 根据当前工作目录中的 `mode` 加载 .env 文件\n  // 设置第三个参数为 '' 来加载所有环境变量，而不管是否有 `VITE_` 前缀。\n  const env = loadEnv(mode, process.cwd(), '')\n  return {\n    // vite 配置\n    define: {\n      __APP_ENV__: env.APP_ENV,\n    },\n  }\n})\n\n")])])]),t("h2",{attrs:{id:"四-共享选项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-共享选项"}},[e._v("#")]),e._v(" 四.共享选项")]),e._v(" "),t("h2",{attrs:{id:"五-服务器选项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五-服务器选项"}},[e._v("#")]),e._v(" 五.服务器选项")])])}),[],!1,null,null,null);t.default=v.exports}}]);