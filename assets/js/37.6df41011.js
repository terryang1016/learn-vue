(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{451:function(n,e,a){"use strict";a.r(e);var l=a(2),t=Object(l.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"_1-元组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-元组"}},[n._v("#")]),n._v(" 1.元组")]),n._v(" "),e("ul",[e("li",[n._v("元祖类型 Tuple")]),n._v(" "),e("li",[n._v("TS中的元祖类型其实就是数组类型的扩展")]),n._v(" "),e("li",[n._v("元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("export default {}\n\n// 元祖类型 Tuple\n// TS中的元祖类型其实就是数组类型的扩展\n// 元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同\n\n// 表示定义了一个名称叫做 tup1 的元祖, 这个元祖中将来可以存储3个元素, \n// 第一个元素必须是字符串类型, 第二个元素必须是数字类型, 第三个元素必须是布尔类型\nlet tup1:[string, number, boolean]; \ntup1 = ['宋祖儿', 100, false];\n// tup1 = ['宋祖儿', 100, true, 200]; // 超过指定的长度会报错\n// tup1 = [100,\"宋祖儿\", true];\n// tup1 = ['杨超越', 100, true];\nconsole.log(tup1); \n\n/* \n  总结:\n  定义: ['', '', ...]\n  作用:元祖用于保存定长定数据类型的数据\n*/\n")])])]),e("h2",{attrs:{id:"_2-any与void"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-any与void"}},[n._v("#")]),n._v(" 2.any与void")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("any:  表示任意类型, 当我们不清楚某个值的具体类型的时候我们就可以使用any")])]),n._v(" "),e("li",[e("p",[n._v("void:  当一个函数没有返回值时，你通常会见到其返回值类型是 void")])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('export default {}\n\n// any类型\n// any表示任意类型, 当我们不清楚某个值的具体类型的时候我们就可以使用any\n// 在TS中任何数据类型的值都可以负责给any类型\n\n// 使用场景一\n// 变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查\nlet salary: any = 1800;    // 数字类型\nsalary = \'my salary is 18k\';    // 字符串类型\nsalary = false;    // 布尔类型\n\n// 使用场景二\n// 改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查\nlet x: any = 4;\nx.ifItExists();    // 正确，ifItExists方法在运行时可能存在，但这里并不会检查\nx.toFixed();    // 正确 \n\n// 使用场景三\n// 定义存储各种类型数据的数组时\nlet beautyList: any[] = [1, false, \'fine\'];\nbeautyList[1] = 100;\n\n\n\n// void类型\n// 某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 \n// 当一个函数没有返回值时，你通常会见到其返回值类型是 void\n// 在TS中只有null和undefined可以赋值给void类型\nfunction makeMoney(): void {\n  console.log("I want to make much money and marry a wife!!!");\n  // return "100K beauty" // 报错\n}\n\nmakeMoney()\n\nlet value:void; \n// 定义了一个不可以保存任意类型数据的变量, 只能保存null和undefined\n// value = 100; // 报错\n// value = "杨紫";// 报错\n// value = true;// 报错\n// 注意点: null和undefined是所有类型的子类型, 所以我们可以将null和undefined赋值给任意类型\n// 严格模式下会null报错\n// value = null; // 不会报错  \nvalue = undefined;// 不会报错\n')])])]),e("h2",{attrs:{id:"_3-never与object"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-never与object"}},[n._v("#")]),n._v(" 3.never与object")]),n._v(" "),e("blockquote",[e("p",[e("strong",[n._v("never类型")]),n._v(":")]),n._v(" "),e("p",[n._v("表示的是那些永不存在的值的类型;")]),n._v(" "),e("p",[n._v("never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型;")]),n._v(" "),e("p",[n._v("变量也可能是 never类型，当它们被永不为真的类型保护所约束")])]),n._v(" "),e("blockquote",[e("p",[e("strong",[n._v("object类型")]),n._v("：")]),n._v(" "),e("p",[e("code",[n._v("object")]),n._v("表示非原始类型，也就是除"),e("code",[n._v("number")]),n._v("，"),e("code",[n._v("string")]),n._v("，"),e("code",[n._v("boolean")]),n._v("，"),e("code",[n._v("symbol")]),n._v("，"),e("code",[n._v("null")]),n._v("或"),e("code",[n._v("undefined")]),n._v("之外的类型")]),n._v(" "),e("p",[n._v("定义了一个只能保存对象的变量")]),n._v(" "),e("p",[n._v("我们后面更常用的是 "),e("code",[n._v("接口")]),n._v(" 与 "),e("code",[n._v("类型别名")])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// Never类型\n// never类型表示的是那些永不存在的值的类型\n// 例如: never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型\n//      变量也可能是 never类型，当它们被永不为真的类型保护所约束时。\n\n// 注意点:never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。\n//  即使 any也不可以赋值给never\n\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message);\n}\n\nerror("鞠婧祎");\n\n// 推断的返回值类型为never\nfunction fail() {\n  return error("Something failed");\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {\n  }\n}\n\n\n// Object类型\n// 表示一个对象\n// 定义了一个只能保存对象的变量\nlet goddess:object; \n// goddess = 1;\n// goddess = "123";\n// goddess = true;\ngoddess = {name:\'白鹿\', age:27};\nconsole.log(goddess);\n')])])]),e("h2",{attrs:{id:"_4-枚举enum"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-枚举enum"}},[n._v("#")]),n._v(" 4.枚举enum")]),n._v(" "),e("ul",[e("li",[e("code",[n._v("enum")]),n._v("类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 枚举用于表示固定的几个取值\n// 例如: 人的性别只能是男或者女\n\nenum Gender{ \n  Male,\n  Femal\n}\n\n// 定义了一个名称叫做val的变量, 这个变量中只能保存Male或者Femal\nlet val:Gender; \nval = Gender.Male;\nval = Gender.Femal;\n// val = 'nan'; // 报错\n// val  = false;// 报错\n\n\n// 注意点: TS中的枚举底层实现的本质其实就是数值类型, 所以赋值一个数值不会报错\nval = 666; // 不会报错\nconsole.log(Gender.Male); // 0\nconsole.log(Gender.Femal);// 1\n\n// 注意点: TS中的枚举类型的取值, 默认是从上至下从0开始递增的\n//         虽然默认是从0开始递增的, 但是我们也可以手动的指定枚举的取值的值\n// 注意点: 如果手动指定了前面枚举值的取值, 那么后面枚举值的取值会根据前面的值来递增\nenum Gender2{ \n  Male=5,\n  Femal\n}\nconsole.log(Gender2.Male); // 5\nconsole.log(Gender2.Femal);// 6\n\n// 注意点: 如果手动指定了后面枚举值的取值, 那么前面枚举值的取值不会受到影响\nenum Gender3{ \n  Male,\n  Femal=10\n}\nconsole.log(Gender3.Male); // 0\nconsole.log(Gender3.Femal);// 10\n\n// 注意点: 我们还可以同时修改多个枚举值的取值, 如果同时修改了多个, 那么修改的是什么最后就是什么\nenum Gender4{ \n  Male=100,\n  Femal=200\n}\nconsole.log(Gender4.Male); // 100\nconsole.log(Gender4.Femal);// 200\n\n// 我们可以通过枚举值拿到它对应的数字\nconsole.log(Gender.Male); // 0\n// 我们还可以通过它对应的数据拿到它的枚举值\nconsole.log(Gender[0]); // Male\n\n")])])]),e("h2",{attrs:{id:"_4-unknown类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-unknown类型"}},[n._v("#")]),n._v(" 4.unknown类型")]),n._v(" "),e("ul",[e("li",[n._v("unknown 类型代表任何值。这与 any 类型类似，但更安全，因为对未知 unknown 值做任何事情都是不合法的。")]),n._v(" "),e("li",[n._v("unknown 类型被称作安全的any")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('export default {}\n\n// unknown 类型代表任何值。这与 any 类型类似，但更安全，因为对未知 unknown 值做任何事情都是不合法的。\n// unknown 类型被称作安全的any\n\n// 1.任何类型都可以赋值给unknown类型\nlet str:unknown;\nstr = 18;\nstr = "张馨予";\nstr = false;\n\n// 2.不能将unknown类型赋值给其它类型\nlet val:unknown = 18;\nlet num: number;\n// num = val; // 报错\n// 使用类型断言\nnum = val as number;\n// 使用类型缩小\nif(typeof val == "number") {\n  num = val;\n}\n\n// 3.unknown与其它任何类型组成的交叉类型最后都是其它类型\ntype MyType1 = number & unknown;\ntype MyType2 = unknown & boolean;\nlet a:MyType1 = 18;\nlet b:MyType2 = true;\n\n\n// 4.unknown除了与any以外, 与其它任何类型组成的联合类型最后都是unknown类型\ntype MyType3 = unknown | any;\ntype MyType4 = unknown | number;\ntype MyType5 = unknown | string | boolean;\n\n\n// 5.never类型是unknown类型的子类型\ntype MyType6 = never extends unknown ? true : false;\n')])])])])}),[],!1,null,null,null);e.default=t.exports}}]);