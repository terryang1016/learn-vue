(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{449:function(t,e,a){"use strict";a.r(e);var n=a(2),r=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一-生命周期函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-生命周期函数"}},[t._v("#")]),t._v(" 一.生命周期函数")]),t._v(" "),e("h3",{attrs:{id:"第一阶段-装载阶段3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一阶段-装载阶段3"}},[t._v("#")]),t._v(" 第一阶段：装载阶段3")]),t._v(" "),e("p",[t._v("​    constructor()\n​    render()\n​    componentDidMount()")]),t._v(" "),e("h3",{attrs:{id:"第二阶段-更新阶段2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二阶段-更新阶段2"}},[t._v("#")]),t._v(" 第二阶段：更新阶段2")]),t._v(" "),e("p",[t._v("​    [shouldComponentUpdate()]\n​    render()\n​    componentDidUpdate()")]),t._v(" "),e("h3",{attrs:{id:"第三阶段-卸载阶段1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三阶段-卸载阶段1"}},[t._v("#")]),t._v(" 第三阶段：卸载阶段1")]),t._v(" "),e("p",[t._v("​    componentWillUnmount()")]),t._v(" "),e("h3",{attrs:{id:"constructor生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#constructor生命周期"}},[t._v("#")]),t._v(" constructor生命周期：")]),t._v(" "),e("p",[t._v("​    (1)当react组件实例化时，是第一个运行的生命周期；\n​    (2)在这个生命周期中，不能使用this.setState()；\n​    (3)在这个生命周期中，不能使用副作用(调接口、dom操作、定时器、长连接等)；\n​    (4)不能把props和state交叉赋值；")]),t._v(" "),e("h3",{attrs:{id:"componentdidmount生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#componentdidmount生命周期"}},[t._v("#")]),t._v(" componentDidMount生命周期：")]),t._v(" "),e("p",[t._v("​    (1)相当于是vue中的mounted；\n​    (2)它表示DOM结构在浏览器中渲染已完成；\n​    (3)在这里可以使用任何的副作用；")]),t._v(" "),e("h3",{attrs:{id:"shouldcomponentupdate-nextprops-nextstate-生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate-nextprops-nextstate-生命周期"}},[t._v("#")]),t._v(" shouldComponentUpdate(nextProps,nextState)生命周期：")]),t._v(" "),e("p",[t._v("​    (1)相当于一个开关，如果返回true则更新机制正常执行，如果为false则更新机制停止；\n​    (2)在vue中是没有的；\n​    (3)存在的意义：可以用于性能优化，但是不常用，最新的解决方案是使用PureComponent；\n​    (4)理论上，这个生命周期的作用，用于精细地控制声明式变量的更新问题，如果变化的声明式变量参与了视图渲染则返回true，如果被变化的声明式变量没有直接或间接参与视图渲染，则返回false；")]),t._v(" "),e("h3",{attrs:{id:"componentdidupdate生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#componentdidupdate生命周期"}},[t._v("#")]),t._v(" componentDidUpdate生命周期：")]),t._v(" "),e("p",[t._v("​    (1)相当于vue中的updated()；\n​    (2)它表示DOM结构渲染更新已完成，只发生在更新阶段；\n​    (3)在这里，可以执行大多数的副作用，但是不建议；\n​    (4)在这里，可以使用this.setState()，但是要有终止条件判断。")]),t._v(" "),e("h3",{attrs:{id:"componentwillunmount生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#componentwillunmount生命周期"}},[t._v("#")]),t._v(" componentWillUnmount生命周期：")]),t._v(" "),e("p",[t._v("​    (1)一般在这里清除定时器、长连接等其他占用内存的构造器；")]),t._v(" "),e("h3",{attrs:{id:"render生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#render生命周期"}},[t._v("#")]),t._v(" render生命周期：")]),t._v(" "),e("p",[t._v("​    (1)render是类组件中唯一必须有的生命周期，同时必须有return（return 返回的jsx默认只能是单一根节点，但是在fragment的语法支持下，可以返回多个兄弟节点）；\n​    (2)Fragment碎片写法: <React.Fragment></React.Fragment> 简写成<></>；\n​    (3)return之前，可以做任意的业务逻辑，但是不能使用this.setState()，会造成死循环；\n​    (4)render()在装载阶段和更新阶段都会运行；\n​    (5)当render方法返回null的时候，不会影响生命周期函数的正常执行。")]),t._v(" "),e("h2",{attrs:{id:"二-react路由懒加载的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-react路由懒加载的实现"}},[t._v("#")]),t._v(" 二.React路由懒加载的实现")]),t._v(" "),e("ul",[e("li",[t._v("*"),e("strong",[t._v("原理*")])])]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("webpack代码分割")]),t._v(" "),e("li",[t._v("React利用 React.lazy与import()实现了渲染时的动态加载")]),t._v(" "),e("li",[t._v("利用Suspense来处理异步加载资源时页面应该如何显示的问题")])])]),t._v(" "),e("ul",[e("li",[e("em",[t._v("1.React.lazy")])])]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("通过lazy() api来动态import需要懒加载的组件")]),t._v(" "),e("li",[t._v("import的组件目前只支持export default的形式导出")]),t._v(" "),e("li",[t._v("Suspense来包裹懒加载的组件进行加载，可以设置fallback现实加载中效果")]),t._v(" "),e("li",[t._v("React.lazy可以结合Router来对模块进行懒加载。")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport { Suspense, lazy } from 'react';\nconst Home = lazy(() => import('./routes/Home'))\nconst AnyComponent = lazy(() => import('./routes/AnyComponent'))\n\n...\nreturn (\n  <Router>\n    <Suspense fallback={<div>Loading...</div>}>\n      <Switch>\n        <Route exact path=\"/\" component={Home}/>\n        <Route path=\"/anyManage\" component={AnyComponent}/>\n        ...\n      </Switch>\n    </Suspense>\n  </Router>\n")])])]),e("p",[e("img",{attrs:{src:"F:%5Cweb-react%5Creact%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"三-react有哪些性能优化的手段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-react有哪些性能优化的手段"}},[t._v("#")]),t._v(" 三.React有哪些性能优化的手段")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/*\n    1、使用纯组件；\n    2、使用 React.memo 进行组件记忆（React.memo 是一个高阶组件），对于相同的输入，不重复执行；\n    3、如果是类组件，使用 shouldComponentUpdate（这是在重新渲染组件之前触发的其中一个生命周期事件）生命周期事件，可以利用此事件来决定何时需要重新渲染组件；\n    4、路由懒加载；\n    5、使用 React Fragments 避免额外标记；\n    6、不要使用内联函数定义（如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例）；\n    7、避免在Willxxx系列的生命周期中进行异步请求，操作dom等；\n    8、如果是类组件，事件函数在Constructor中绑定bind改变this指向；\n    9、避免使用内联样式属性；\n    10、优化 React 中的条件渲染；\n    11、不要在 render 方法中导出数据；\n    12、列表渲染的时候加key；\n    13、在函数组件中使用useCallback和useMemo来进行组件优化，依赖没有变化的话，不重复执行；\n    14、类组件中使用immutable对象；\n*/\n")])])]),e("h2",{attrs:{id:"四-react组件通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-react组件通信"}},[t._v("#")]),t._v(" 四.React组件通信")]),t._v(" "),e("h3",{attrs:{id:"_1-react本身"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-react本身"}},[t._v("#")]),t._v(" 1.react本身:")]),t._v(" "),e("p",[t._v("​                (1)"),e("strong",[t._v("props")]),t._v("——父组件向子组件通过props传参\n​                (2)"),e("strong",[t._v("实例方法")]),t._v("——在父组件中可以用 "),e("strong",[t._v("refs")]),t._v(" 引用子组件，之后就可以调用子组件的实例方法了\n​                (3)"),e("strong",[t._v("回调函数")]),t._v("——用于子组件向父组件通信，子组件调用props传递过来的方法\n​                (4)"),e("strong",[t._v("状态提升")]),t._v("——两个子组件可以通过父组件定义的参数进行传参\n​                (5)"),e("strong",[t._v("Context上下文")]),t._v("——一般用作全局主题")]),t._v(" "),e("h3",{attrs:{id:"_2-状态管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-状态管理"}},[t._v("#")]),t._v(" 2.状态管理:")]),t._v(" "),e("p",[t._v("​            (1) mobx/redux/dva——通过在view中触发action，改变state，进而改变其他组件的view")]),t._v(" "),e("h3",{attrs:{id:"五-类组件、函数组件怎么做性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-类组件、函数组件怎么做性能优化"}},[t._v("#")]),t._v(" 五.类组件、函数组件怎么做性能优化？")]),t._v(" "),e("h3",{attrs:{id:"_1-类组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-类组件"}},[t._v("#")]),t._v(" 1.类组件：")]),t._v(" "),e("p",[t._v("​    （1）使用shouldComponentUpdate：这个生命周期可以让我们决定当前状态或属性的改变是否重新渲染组件，默认返回ture，返回false时不会执行render，在初始化渲染或使用forceUpdate()时不会调用；如果在shouldComponentUpdate比较的值是引用类型的话，可能达不到我们想要的效果，因为引用类型指向同一个地址；\n​        当将旧的state的值原封不动赋值给新的state（即不改变state的值，但是调用了setState）和 无数据交换的父组件的重新渲染都会导致组件重新渲染，这时候都可以通过shouldComponentUpdate来优化；\n​    （2）React.PureComponent：基本上和Component用法一致，不同之处在于 PureComponent不需要开发者自己设置shouldComponentUpdate，因为PureComponent自带通过props和state的浅对比来实现 shouldComponentUpate；但是如果props和state对象包含复杂的数据结构，它可能会判断错误(表现为对象深层的数据已改变，视图却没有更新）；\n​    （3）使用Immutable：immutable是一种持久化数据，一旦被创建就不会被修改，修改immutable对象的时候返回新的immutable；也就是说在使用旧数据创建新数据的时候，会保证旧数据同时可用且不变；为了避免深度复制所有节点的带来的性能损耗，immutable使用了结构共享，即如果对象树中的一个节点发生变化，只修改这个节点和受他影响的父节点，其他节点仍然共享；\n​    （4）bind函数：在react中改变this的指向有三种方法，a)constructor中用bind绑定; b)使用时通过bind绑定; 3)使用箭头函数；选择第一种只在组件初始化的时候执行一次，第二种组件在每次render都要重新绑定，第三种在每次render时候都会生成新的箭头函数，所以选择第一种；")]),t._v(" "),e("h3",{attrs:{id:"_2-函数组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数组件"}},[t._v("#")]),t._v(" 2.函数组件：")]),t._v(" "),e("p",[t._v("​    （1）useCallback：接收一个函数作为参数，接收第二个参数作为依赖列表，返回值为函数，有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改变时才重新计算；可以使用useCallback把要传递给子组件的函数包裹起来，这样父组件刷新的时候，传递给子组件的函数指向不会发生改变，可以减少子组件的渲染次数；")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const handleUseCallback=useCallback(handleClick,[])\n            <Child handleClick={handleUseCallback} />\n")])])]),e("p",[t._v("​    （2）useMemo：useMemo的使用和useCallback差不多，只是useCallback返回的是一个函数，useMemo返回值可以是函数、对象等都可以；")]),t._v(" "),e("p",[t._v("两者都可使用：\n（1）React.memo：React.memo 功能同React.PureComponent，但React.memo是高阶组件，既可以用在类组件中也可以用在函数组件中；memo还可以接收第二个参数，是一个可定制化的比较函数，其返回值与 shouldComponentUpdate的相反；\n（2）使用key：在列表渲染时使用key，这样当组件发生增删改、排序等操作时，diff运算后可以根据key值直接调整DOM顺序，避免不必要的渲染而避免性能的浪费；\n（3）不要滥用props：尽量只传需要的数据，避免多余的更新，尽量避免使用{…props}；")])])}),[],!1,null,null,null);e.default=r.exports}}]);