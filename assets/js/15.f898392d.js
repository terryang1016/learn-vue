(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{431:function(a,n,s){"use strict";s.r(n);var t=s(2),e=Object(t.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"js实现继承的6种方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js实现继承的6种方式"}},[a._v("#")]),a._v(" Js实现继承的6种方式")]),a._v(" "),n("h2",{attrs:{id:"继承的目的-重复利用另外一个对象的属性和方法。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#继承的目的-重复利用另外一个对象的属性和方法。"}},[a._v("#")]),a._v(" 继承的目的：重复利用另外一个对象的属性和方法。")]),a._v(" "),n("h3",{attrs:{id:"_1-原型链继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-原型链继承"}},[a._v("#")]),a._v(" 1.原型链继承")]),a._v(" "),n("p",[a._v("让一个构造函数的原型是另一个类型的实例，那么这个构造函数new出来的实例就具有该实例的属性。")]),a._v(" "),n("p",[a._v("当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//父类\nfunction ParentClass(name) {\n    this.name = name\n}\nParentClass.prototype.eatName = 'xx';\nParentClass.prototype.eat = function (name) {\n    console.log('这是一个' + name);\n};\n//子类\nfunction ChildClass(age) {\n    this.age = age\n}\n\n/* 将 ChildClass 的原型直接赋值为 ParentClass的构造函数，\n    所以此时ChildClass的原型对象中的 constructor其实是指向ParentClass的构造函数的，\n    所以我们这边要修改回来，不然引起原型链的絮乱 */\nChildClass.prototype = new ParentClass();\nChildClass.prototype.constuctor = ChildClass;\nlet obj = new ChildClass('12', 22);\nobj.eat('西红柿');\nconsole.log(obj.eatName); // xx\n")])])]),n("p",[a._v("缺点：只能继承父类原型上的方法和属性，不能继承父类的实例属性和方法，多个实例对引用类型的操作会被篡改。")]),a._v(" "),n("h3",{attrs:{id:"_2-借用构造函数继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-借用构造函数继承"}},[a._v("#")]),a._v(" 2.借用构造函数继承")]),a._v(" "),n("p",[a._v("使用**parentClass.call(this)**改变this的指向来调用父类的属性和方法")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//父类\nfunction ParentClass(name) {\n    this.name = name;\n    this.eat = function(){\n        console.log('这是一个' + name);\n    }\n}\n\n//子类\nfunction ChildClass(name,age) {\n    ParentClass.call(this,name)\n    this.age = age\n}\n\nlet obj = new ChildClass('西红柿', 22);\nconsole.log(obj.name,obj.age);\nobj.eat() // 这是一个西红柿\n")])])]),n("p",[a._v("缺点：只能继承父类实例e的属性和方法，不能继承原型上的属性和方法")]),a._v(" "),n("h3",{attrs:{id:"_3-组合继承-经典继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-组合继承-经典继承"}},[a._v("#")]),a._v(" 3.组合继承（经典继承）")]),a._v(" "),n("p",[a._v("以上二种继承方式的组合")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//父类\nfunction ParentClass(name) {\n    this.name = name;\n}\nParentClass.prototype.eatName = 'xx';\nParentClass.prototype.eat = function () {\n    console.log('这是一个' + this.name);\n};\n//子类\nfunction ChildClass(name,age) {\n    ParentClass.call(this,name)\n    this.age = age\n}\n/* \n    将 ChildClass 的原型直接赋值为 ParentClass的构造函数，\n    所以此时ChildClass的原型对象中的 constructor其实是指向ParentClass的构造函数的，\n    所以我们这边要修改回来，不然引起原型链的絮乱 \n*/\nChildClass.prototype = new ParentClass();\nChildClass.prototype.constuctor = ChildClass;\nlet obj = new ChildClass('西红柿', 22);\nconsole.log(obj.name,obj.age);\nobj.eat() // 这是一个西红柿\n")])])]),n("h3",{attrs:{id:"_4-原型式继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-原型式继承"}},[a._v("#")]),a._v(" 4.原型式继承")]),a._v(" "),n("h4",{attrs:{id:"方法一-借用构造函数在一个函数a内部创建一个临时性的构造函数-然后将传入的对象作为这个构造函数的原型-最后返回这个临时类型的一个新实例。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法一-借用构造函数在一个函数a内部创建一个临时性的构造函数-然后将传入的对象作为这个构造函数的原型-最后返回这个临时类型的一个新实例。"}},[a._v("#")]),a._v(" 方法一：借用构造函数在一个函数A内部创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。")]),a._v(" "),n("p",[a._v("本质上，函数A是"),n("strong",[a._v("对传入的对象执行了一次浅复制")]),a._v("。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function createObject(obj) {\n  function Fun() {}\n  Fun.prototype = obj\n  return new Fun()\n}\n \nlet person = {\n  name: 'mjy',\n  age: 18,\n  hoby: ['唱', '跳'],\n  showName() {\n    console.log('my name is:', this.name)\n  }\n}\n \nlet child1 = createObject(person)\nchild1.name = 'xxxy'\nchild1.hoby.push('rap')\nlet child2 = createObject(person)\n \nconsole.log(child1)\nconsole.log(child2)\nconsole.log(person.hoby) // ['唱', '跳', 'rap']\n")])])]),n("h4",{attrs:{id:"方法二-object-create"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法二-object-create"}},[a._v("#")]),a._v(" 方法二：Object.create()")]),a._v(" "),n("p",[a._v("Object.create() 是把现有对象的属性，挂到新建对象的原型上，新建对象为空对象")]),a._v(" "),n("p",[a._v("ECMAScript 5通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的函数A方法效果相同。")]),a._v(" "),n("p",[n("strong",[a._v("利用Object.creat(parentClass)创建一个原型指向parentClass的对象")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("let parentClass = {\n    name: '西红柿'\n};\nlet ChildClass = Object.create(parentClass);\nChildClass.age = 11;\nconsole.log(ChildClass.name,ChildClass.age); //西红柿 11\n")])])]),n("p",[a._v("缺点：无法传递参数，原型链继承多个实例时，实例引用类型指向相同，存在篡改的可能")]),a._v(" "),n("h3",{attrs:{id:"_5-寄生式继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-寄生式继承"}},[a._v("#")]),a._v(" 5.寄生式继承")]),a._v(" "),n("p",[a._v("在"),n("strong",[a._v("原型上的基础上新增属性和方法增强函数")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("let parentClass = {\n    name: '西红柿'\n};\n\nfunction clone(original){\n    let obj = Object.create(original);\n    obj.eat = function(){\n        console.log('这是一个' + this.name); //西红柿\n    }\n    return obj;\n}\n\nlet ChildClass = clone(parentClass);\nconsole.log(ChildClass.name);\nChildClass.eat();\n")])])]),n("p",[a._v("缺点：（同上原型式继承）无法传递参数，原型链继承多个实例时，实例引用类型指向相同，存在篡改的可能")]),a._v(" "),n("h3",{attrs:{id:"_6-寄生组合式继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-寄生组合式继承"}},[a._v("#")]),a._v(" 6.寄生组合式继承")]),a._v(" "),n("p",[a._v("将组合式和寄生式结合起来")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//父类\nfunction ParentClass(name) {\n    this.name = name;\n}\nParentClass.prototype.eat = function () {\n    console.log('这是一个' + this.name);\n};\n//子类\nfunction ChildClass(name,age) {\n    ParentClass.call(this,name)\n    this.age = age\n}\n\n/* \n    这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程\n*/\nChildClass.prototype = Object.create(ParentClass.prototype);\nChildClass.prototype.constuctor = ChildClass;\n\nlet obj = new ChildClass('西红柿', 22);\nobj.eat();\nconsole.log(obj.age); // 22\n")])])]),n("p",[a._v("混入方式继承多个对象")]),a._v(" "),n("p",[a._v("在寄生组合方法中的Object.creat()的下一行"),n("strong",[a._v("使用Object.assin()混合其它的类")]),a._v("，Object.assin()会把所有可枚举的属性从一个或多个原对象复制到目标对象。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("/* \n    这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程\n*/\nChildClass.prototype = Object.create(ParentClass.prototype);\n//混合其它\nObject.assign(ChildClass.prototype,ParentClass1.prototype)\nChildClass.prototype.constuctor = ChildClass;\n\nconsole.log(ChildClass);\nlet obj = new ChildClass('西红柿', 22, 10);\n    obj.eat();\n    console.log(obj.age,obj.name,obj.count); // 22\n")])])]),n("h3",{attrs:{id:"_7-es6、class实现继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-es6、class实现继承"}},[a._v("#")]),a._v(" 7.ES6、Class实现继承")]),a._v(" "),n("p",[a._v("用extends继承父类，在子类的construtor调用super()。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//父类\nclass ParentClass {\n    constructor(name){\n        this.name = name\n    }\n    eat(){\n        console.log('这是一个' + this.name);\n    }\n}\n\n//子类\nclass ChildClass extends ParentClass{\n    constructor(name,age){\n        super(name)\n        this.age = age\n    }\n}\n\nlet obj = new ChildClass('西红柿', 22);\n    obj.eat();\n    console.log(obj.name,obj.age); // 西红柿 22\n")])])]),n("p",[n("strong",[a._v("ES5继承和ES6继承的区别：")])]),a._v(" "),n("p",[a._v("ES5："),n("strong",[a._v("先创建子类的实例对象")]),a._v("，再把父类的属性和方法添加到this上面（Parent.apply(this)）。")]),a._v(" "),n("p",[a._v("ES6："),n("strong",[a._v("先创建父类的实例对象this")]),a._v("，再用子类的构造函数修改this。因为"),n("strong",[a._v("子类没有自己的this，所以必须调用父类的super()方法")]),a._v("，否则新建实例会报错")])])}),[],!1,null,null,null);n.default=e.exports}}]);